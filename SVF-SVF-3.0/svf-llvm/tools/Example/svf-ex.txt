//===- svf-ex.cpp -- A driver example of SVF-------------------------------------//
//
//                     SVF: Static Value-Flow Analysis
//
// Copyright (C) <2013->  <Yulei Sui>
//

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
//===-----------------------------------------------------------------------===//

/*
 // A driver program of SVF including usages of SVF APIs
 //
 // Author: Yulei Sui,
 */

 #include "AE/Svfexe/SVFIR2AbsState.h"
 #include "Graphs/SVFG.h"
 #include "SVF-LLVM/LLVMUtil.h"
 #include "SVF-LLVM/SVFIRBuilder.h"
 #include "Util/CommandLine.h"
 #include "Util/Options.h"
 #include "WPA/Andersen.h"
 #include "/home/cs23mtech12010/CCM/SVF-SVF-3.0/svf/include/MTA/TCT.h"
#include "/home/cs23mtech12010/CCM/SVF-SVF-3.0/svf/include/MTA/MHP.h"
#include "/home/cs23mtech12010/CCM/SVF-SVF-3.0/svf/include/MTA/MTA.h"
#include "/home/cs23mtech12010/CCM/SVF-SVF-3.0/svf/include/MTA/FSMPTA.h"
 using namespace llvm;
 using namespace std;
 using namespace SVF;
 using namespace SVFUtil;
 
 /*!
  * An example to query alias results of two SVF values
  */
 SVF::AliasResult aliasQuery(PointerAnalysis* pta, const SVFValue* v1, const SVFValue* v2)
 {
     return pta->alias(v1, v2);
 }
 
 /*!
  * An example to print points-to set of an SVF value
  */
 std::string printPts(PointerAnalysis* pta, const SVFValue* svfval)
 {
 
     std::string str;
     raw_string_ostream rawstr(str);
 
    
    //  llvm::errs()<<" analysing the points to of 000" <<svfval->toString()<<"\n";
 
 
 
     NodeID pNodeId = pta->getPAG()->getValueNode(svfval);
     const PointsTo& pts = pta->getPts(pNodeId);
     for (PointsTo::iterator ii = pts.begin(), ie = pts.end();
             ii != ie; ii++)
     {
         rawstr << " " << *ii << " ";
         PAGNode* targetObj = pta->getPAG()->getGNode(*ii);
        //  if(targetObj->hasValue())
        //  {
             rawstr << "(" << targetObj->getValue()->toString() << ")\t ";
        //  }
     }
 
 
 
 
 
     return rawstr.str();
 
 }
 
 /*!
  * An example to query/collect all SVFStmt from a ICFGNode (iNode)
  */
 void traverseOnSVFStmt(const ICFGNode* node)
 {
     AbstractState es;
     SVFIR2AbsState* svfir2AbsState = new SVFIR2AbsState(SVFIR::getPAG());
     for (const SVFStmt* stmt: node->getSVFStmts())
     {
         if (const AddrStmt *addr = SVFUtil::dyn_cast<AddrStmt>(stmt))
         {
             svfir2AbsState->handleAddr(es, addr);
         }
         else if (const BinaryOPStmt *binary = SVFUtil::dyn_cast<BinaryOPStmt>(stmt))
         {
             svfir2AbsState->handleBinary(es, binary);
         }
         else if (const CmpStmt *cmp = SVFUtil::dyn_cast<CmpStmt>(stmt))
         {
             svfir2AbsState->handleCmp(es, cmp);
         }
         else if (const LoadStmt *load = SVFUtil::dyn_cast<LoadStmt>(stmt))
         {
             svfir2AbsState->handleLoad(es, load);
         }
         else if (const StoreStmt *store = SVFUtil::dyn_cast<StoreStmt>(stmt))
         {
             svfir2AbsState->handleStore(es, store);
         }
         else if (const CopyStmt *copy = SVFUtil::dyn_cast<CopyStmt>(stmt))
         {
             svfir2AbsState->handleCopy(es, copy);
         }
         else if (const GepStmt *gep = SVFUtil::dyn_cast<GepStmt>(stmt))
         {
             if (gep->isConstantOffset())
             {
                 gep->accumulateConstantByteOffset();
                 gep->accumulateConstantOffset();
             }
             svfir2AbsState->handleGep(es, gep);
         }
         else if (const SelectStmt *select = SVFUtil::dyn_cast<SelectStmt>(stmt))
         {
             svfir2AbsState->handleSelect(es, select);
         }
         else if (const PhiStmt *phi = SVFUtil::dyn_cast<PhiStmt>(stmt))
         {
             svfir2AbsState->handlePhi(es, phi);
         }
         else if (const CallPE *callPE = SVFUtil::dyn_cast<CallPE>(stmt))
         {
             // To handle Call Edge
             svfir2AbsState->handleCall(es, callPE);
         }
         else if (const RetPE *retPE = SVFUtil::dyn_cast<RetPE>(stmt))
         {
             svfir2AbsState->handleRet(es, retPE);
         }
         else
             assert(false && "implement this part");
     }
 }
 
 
 /*!
  * An example to query/collect all successor nodes from a ICFGNode (iNode) along control-flow graph (ICFG)
  */
 std::vector<const CallICFGNode*> traverseOnICFG(ICFG* icfg, const ICFGNode* iNode,ThreadCallGraph* tcg)
 {
     std::vector<const CallICFGNode*>  jnodes ;
     FIFOWorkList<const ICFGNode*> worklist;
     Set<const ICFGNode*> visited;
     worklist.push(iNode);
 
            //  llvm::errs()<<" ------------------initially ---------------\n";
            //  iNode->dump();
         /// Traverse along VFG
     while (!worklist.empty())
     {
         const ICFGNode* vNode = worklist.pop();
 
         const CallICFGNode* join = SVFUtil::dyn_cast<CallICFGNode>(vNode);
 
         if(join && tcg->getThreadAPI()->isTDJoin(join->getCallSite())){
                      
            // llvm::errs()<<" traversing the ICFG -----------\n";
            // join->dump();
             jnodes.push_back(join);
         }
 
         // vNode->dump();
         for (ICFGNode::const_iterator it = vNode->OutEdgeBegin(), eit =
                     vNode->OutEdgeEnd(); it != eit; ++it)
         {
             ICFGEdge* edge = *it;
             ICFGNode* succNode = edge->getDstNode();
             if (visited.find(succNode) == visited.end())
             {
 
                 visited.insert(succNode);
                 worklist.push(succNode);
             }
         }
     }
     return jnodes;
 }
 
 void dummyVisit(const VFGNode* node)
 {
 
 }
 /*!
  * An example to query/collect all the uses of a definition of a value along value-flow graph (VFG)
  */
 void traverseOnVFG( SVFG* vfg, const SVFValue* svfval)
 {
     SVFIR* pag = SVFIR::getPAG();
     PAGNode* pNode = pag->getGNode(pag->getValueNode(svfval));
     if (!vfg->hasDefSVFGNode(pNode))
         return;
     const VFGNode* vNode = vfg->getDefSVFGNode(pNode);
     FIFOWorkList<const VFGNode*> worklist;
     Set<const VFGNode*> visited;
     worklist.push(vNode);
 
     /// Traverse along VFG
     while (!worklist.empty())
     {
         const VFGNode* vNode = worklist.pop();
         for (VFGNode::const_iterator it = vNode->OutEdgeBegin(), eit =
                     vNode->OutEdgeEnd(); it != eit; ++it)
         {
             VFGEdge* edge = *it;
             VFGNode* succNode = edge->getDstNode();
             if (visited.find(succNode) == visited.end())
             {
                 visited.insert(succNode);
                 worklist.push(succNode);
             }
         }
     }
 
     /// Collect all LLVM Values
     for(Set<const VFGNode*>::const_iterator it = visited.begin(), eit = visited.end(); it!=eit; ++it)
     {
         const VFGNode* node = *it;
         dummyVisit(node);
         /// can only query VFGNode involving top-level pointers (starting with % or @ in LLVM IR)
         /// PAGNode* pNode = vfg->getLHSTopLevPtr(node);
         /// Value* val = pNode->getValue();
     }
 }
 
 void func3(TCT * tct){


 }
void fun( std::vector<const CallICFGNode* > h){}

 void fun4(MHP *mhp){}

 int main(int argc, char ** argv)
 {
 
     std::vector<std::string> moduleNameVec;
     moduleNameVec = OptionBase::parseOptions(
                         argc, argv, "Whole Program Points-to Analysis", "[options] <input-bitcode...>"
                     );
 
     if (Options::WriteAnder() == "ir_annotator")
     {
         LLVMModuleSet::preProcessBCs(moduleNameVec);
     }
 
     SVFModule* svfModule = LLVMModuleSet::buildSVFModule(moduleNameVec);
 
     /// Build Program Assignment Graph (SVFIR)
     SVFIRBuilder builder(svfModule);
     SVFIR* pag = builder.build();
     
      
     /// Create Andersen's pointer analysis
    //  Andersen* ander = AndersenWaveDiff::createAndersenWaveDiff(pag);
 
     MTA mta;
    mta.runOnModule(pag);
    MHP *mhp = mta.getMHP();
   
    LockAnalysis* la = mta.getLockAnalysis();
    FSMPTA*  multi_pta  =  FSMPTA::createFSMPTA(svfModule, mhp,la);
    multi_pta->initialize(svfModule);
    // pag= multi_pta->getPAG();
    TCT * tct =  mhp->getTCT();
    func3(tct);
    fun4(mhp);
     tct->print();
     /// Call Graph
     PTACallGraph* callgraph = multi_pta->getPTACallGraph();
 
     /// ICFG
     ICFG* icfg = pag->getICFG();
 
     /// Value-Flow Graph (VFG)
     VFG* vfg = new VFG(callgraph);
 
     /// Sparse value-flow graph (SVFG)
     SVFGBuilder svfBuilder;
    // SVFG* svfg = svfBuilder.build(ander);
    // SVFG* svfg = svfBuilder.buildFullSVFG(ander);


for (const std::pair<const NodeID, TCTNode*>& tpair : *tct){
        std::cout<<tpair.first<<"\n";
        NodeID  id = tpair.first;
        TCTNode* current_thred = tct->getTCTNode(id);
        llvm::errs()<<"-------------------------------dumping current  thread  ----------------\n";
        current_thred->dump();
        // const CxtThread& ct = tpair.second->getCxtThread();
        // auto ctx =ct.getContext();
        // llvm::errs()<<"-------------------------------dumping context of the thread  ----------------\n";
        // ct.dump();



     }

      for (const std::pair<const NodeID, TCTNode*>& tpair : *tct)
    {
        const CxtThread& ct = tpair.second->getCxtThread();
        std::vector<u32_t> ctx =ct.getContext();
        // errs()<<"-------------------------------dumping context of the thread  ----------------\n";
        // ct.dump();
        // errs()<<"-------------------------------done -dumping context of the thread  ----------------\n";
        // NodeID  id = tpair.first;
        // TCTNode* thread_node = tpair.second;
        const auto  routine = tct->getStartRoutineOfCxtThread(ct);
        const SVFInstruction* svfInst = routine->getEntryBlock()->front();
        // if(auto pp = SVFUtil::dyn_cast<llvm::BasicBlock>(LLVMModuleSet::getLLVMModuleSet()->getLLVMValue(routine->getEntryBlock())))
        //                 {
        //                             llvm::errs()<<*pp<<"*******Basic block printing ********** \n";
        //                 }
        auto tcg = tct->getThreadCallGraph();

        ICFGNode*   icf =  icfg->getICFGNode(svfInst);

        std::vector<const CallICFGNode* > jnodes = traverseOnICFG(icfg, icf,tcg);

        fun(jnodes);
         llvm::errs()<<"----------------finally-----------------\n" ;
        // NodeBS getDirAndIndJoinedTid(const CallStrCxt& cxt, const ICFGNode* call);
        // if(jnode)
        // jnode->dump();
        // TCTNode* current_thred = tct->getTCTNode(id);
        // llvm::errs()<<"\n\n\n<<<<<<<<<<<<<<<<<<<<<<<<current analysing thread >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n \n";
        // current_thred->dump();
        for (const CallICFGNode* jnode : jnodes)
        {
                
            // CxtStmt cs(cxt, call);
                llvm::errs()<<jnode->getCallSite()->toString()<<"\n";
                // isAliasedForkJoin(SVFUtil::cast<CallICFGNode>(forkSite), SVFUtil::cast<CallICFGNode>(joinSite))  use this to get the threadID
                // TCTNode* joined_node = tct->getTCTNode(jnode->getId());
                // joined_node->dump();
            //     llvm::errs()<<"\n <<<<<<<<<<<<<<<<<<<<<<<jnode >>>>>>>>>>>>>>>>>>>>>>> \n\n";
            //    // ctx.dump();
            //   auto joins_ids = mhp->getDirAndIndJoinedTid(ctx,jnode);
            //     llvm::errs()<<" \n\n\n <<<<<<<<<<<<<<<<<<<<<<<<list of threads joined in the current analysing thread >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n";
            //     for (const unsigned i : joins_ids)
            //     {
            //         TCTNode* joined_node = tct->getTCTNode(i);
            //         joined_node->dump();
            //         llvm::errs()<<"\n <<<<<<<<<<<<<<<<<<<<<<<jnode >>>>>>>>>>>>>>>>>>>>>>> \n\n";
            //     }
            // errs()<<ct.cxtToStr()<<"  \n";


        }
    }
     PointerAnalysis* pta = SVF::FlowSensitive::createFSWPA(pag);
PointerAnalysis* pta1  =tct->getPTA();
 SVFG* svfg1 = svfBuilder.buildFullSVFG(dyn_cast<SVF::BVDataPTAImpl>(pta));

 llvm::errs()<<"\n\n---------something--------done-----------------\n\n\n";
     /// Collect uses of an LLVM Value
     if (1)
     {
         for (const auto& it : *svfg1)
         {
            // llvm::errs()<<"------------------dumping the SVFG-----------------\n";
             const SVFGNode* node = it.second;

             if (node->getValue())
             {
                llvm::errs()<<"------------------pointer -----------------\n";
                llvm::errs()<<node->getValue()->toString()<<"\n";

                llvm::errs()<<"------------------points to results -----------------\n";
                 //traverseOnVFG(svfg, node->getValue());
                 /// Print points-to information
                std::cout<< printPts(pta1, node->getValue())<<"\n";
                 for (const SVFGEdge* edge : node->getOutEdges())
                 {
                     const SVFGNode* node2 = edge->getDstNode();
                     if (node2->getValue())
                         aliasQuery(multi_pta, node->getValue(), node2->getValue());
                 }
             }
         }
     }


     
 
     /// Collect all successor nodes on ICFG
    //  if (Options::PTSPrint())
    //  {
    //      for (const auto& it : *icfg)
    //      {
    //          const ICFGNode* node = it.second;
    //        //  traverseOnICFG(icfg, node);
    //      }
    //  }
 
     // clean up memory
     delete vfg;
     AndersenWaveDiff::releaseAndersenWaveDiff();
     SVFIR::releaseSVFIR();
 
     LLVMModuleSet::getLLVMModuleSet()->dumpModulesToFile(".svf.bc");
     SVF::LLVMModuleSet::releaseLLVMModuleSet();
     llvm::llvm_shutdown();
     return 0;
 }
 
 